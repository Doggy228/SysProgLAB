CompileException.java
======================================================================
package edu.kpi.io8322.sysprog.lab.core;

import edu.kpi.io8322.sysprog.lab.PythonCompiler;
import edu.kpi.io8322.sysprog.lab.lexical.TokenInvalid;
import lombok.Getter;

@Getter
public class CompileException extends Exception {
    private int row;
    private int col;

    public CompileException(int row, int col, String message, Throwable cause) {
        super(message, cause);
        this.row = row;
        this.col = col;
    }

    public CompileException(TokenInvalid token) {
        super(token.getErrMsg(), null);
        this.row = token.getRow();
        this.col = token.getCol();
    }

    @Override
    public String toString() {
        return PythonCompiler.app.getSrcname() +
                "[" + row + "," + col + "]->[" + PythonCompiler.app.getSrclines().get(row - 1) + "]" + System.lineSeparator() + String.format("%1$50s %2$s", "ERR: ", getMessage());
    }
}
LexFabric.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

import java.util.HashMap;
import java.util.Map;

public class LexFabric {
    private Map<LexTypeEnum, LexType> lexTypeMap;
    private Map<Character, LexType_symb> lexTypeSymbMap;
    private Map<String, LexType_keyword> lexTypeKeywordMap;

    public LexFabric(LexicalAnalyzer lexicalAnalyzer) {
        lexTypeMap = new HashMap<>();
        lexTypeMap.put(LexTypeEnum.NONE, new LexType_none());
        lexTypeMap.put(LexTypeEnum.BLOCKINDENT, new LexType_blockindent());
        lexTypeMap.put(LexTypeEnum.BKTB, new LexType_bktb());
        lexTypeMap.put(LexTypeEnum.BKTE, new LexType_bkte());
        lexTypeMap.put(LexTypeEnum.COLON, new LexType_colon());
        lexTypeMap.put(LexTypeEnum.QUOTE1, new LexType_quote1());
        lexTypeMap.put(LexTypeEnum.QUOTE2, new LexType_quote2());
        lexTypeMap.put(LexTypeEnum.DEF, new LexType_def());
        lexTypeMap.put(LexTypeEnum.RETURN, new LexType_return());
        lexTypeMap.put(LexTypeEnum.CONSTINT, new LexType_constint());
        lexTypeMap.put(LexTypeEnum.CONSTCHAR, new LexType_constchar());
        lexTypeMap.put(LexTypeEnum.ID, new LexType_id());

        lexTypeSymbMap = new HashMap<>();
        lexTypeSymbMap.put(Character.valueOf('('), (LexType_symb) getLexType(LexTypeEnum.BKTB));
        lexTypeSymbMap.put(Character.valueOf(')'), (LexType_symb) getLexType(LexTypeEnum.BKTE));
        lexTypeSymbMap.put(Character.valueOf(':'), (LexType_symb) getLexType(LexTypeEnum.COLON));
        lexTypeSymbMap.put(Character.valueOf('\''), (LexType_symb) getLexType(LexTypeEnum.QUOTE1));
        lexTypeSymbMap.put(Character.valueOf('\"'), (LexType_symb) getLexType(LexTypeEnum.QUOTE2));

        lexTypeKeywordMap = new HashMap<>();
        lexTypeKeywordMap.put("def", (LexType_keyword) getLexType(LexTypeEnum.DEF));
        lexTypeKeywordMap.put("return", (LexType_keyword) getLexType(LexTypeEnum.RETURN));

    }

    public LexType getLexType(LexTypeEnum type) {
        return lexTypeMap.get(type);
    }

    public LexType_symb getLexType_symb(char value) {
        return lexTypeSymbMap.get(Character.valueOf(value));
    }

    public LexType_keyword getLexType_keyword(String value) {
        return lexTypeKeywordMap.get(value);
    }
}
LexicalAnalyzer.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

import edu.kpi.io8322.sysprog.lab.PythonCompiler;
import edu.kpi.io8322.sysprog.lab.core.CompileException;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
public class LexicalAnalyzer {
    private List<String> srclines;
    private List<Token> tokenList;
    private LexFabric lexFabric;

    public LexicalAnalyzer(List<String> srclines) {
        this.srclines = srclines;
        this.lexFabric = new LexFabric(this);
    }

    public void exec() throws CompileException {
        PythonCompiler.app.logInfo(null, null, "Lexical analyzer starting.");
        tokenList = new ArrayList<>();
        for (int row = 0; row < srclines.size(); row++) {
            String line = srclines.get(row);
            int block_indent = 0;
            while (block_indent < line.length() && line.charAt(block_indent) == ' ') {
                block_indent++;
            }
            if (block_indent > line.length()) continue;
            tokenList.add(new Token(lexFabric.getLexType(LexTypeEnum.BLOCKINDENT), row + 1, 1, line.substring(0, block_indent)));
            int col = block_indent;
            while (col < line.length()) {
                if (line.charAt(col) == ' ') {
                    col++;
                    continue;
                }
                LexType lexType = lexFabric.getLexType_symb(line.charAt(col));
                if (lexType != null) {
                    Token token = new Token(lexType, row + 1, col + 1, null);
                    tokenList.add(token);
                    col++;
                    if (lexType.getType() == LexTypeEnum.QUOTE1 || lexType.getType() == LexTypeEnum.QUOTE2) {
                        if (col + 1 >= line.length()) {
                            TokenInvalid tokenInvalid = new TokenInvalid(lexFabric, row + 1, col + 1, null, "Not a closed quote.");
                            tokenList.add(tokenInvalid);
                            tokenInvalid.throwCompileException();
                        }
                        tokenList.add(new Token(lexFabric.getLexType(LexTypeEnum.CONSTCHAR), row + 1, col + 1, line.substring(col, col + 1)));
                        col++;
                        LexType lexType2 = lexFabric.getLexType_symb(line.charAt(col));
                        if (lexType2 == null || lexType2.getType() != lexType.getType()) {
                            TokenInvalid tokenInvalid = new TokenInvalid(lexFabric, row + 1, col + 1, line.substring(col, col + 1), "Bad closed quote.");
                            tokenList.add(tokenInvalid);
                            tokenInvalid.throwCompileException();
                        }
                        tokenList.add(new Token(lexType2, row + 1, col + 1, null));
                        col++;
                    }
                    continue;
                }
                int next = searchToken(line, col);
                if (col == next) {
                    TokenInvalid tokenInvalid = new TokenInvalid(lexFabric, row + 1, col + 1, line.substring(col, col + 1), "Bad symbol.");
                    tokenList.add(tokenInvalid);
                    tokenInvalid.throwCompileException();
                }
                String tokenValue = line.substring(col, next);
                lexType = lexFabric.getLexType_keyword(tokenValue);
                if (lexType != null) {
                    tokenList.add(new Token(lexType, row + 1, col + 1, null));
                    col = next;
                    continue;
                }
                if (checkConstInt(tokenValue, row+1, col+1)) {
                    tokenList.add(new Token(lexFabric.getLexType(LexTypeEnum.CONSTINT), row + 1, col + 1, tokenValue));
                    col = next;
                    continue;
                }
                if (checkId(tokenValue)) {
                    tokenList.add(new Token(lexFabric.getLexType(LexTypeEnum.ID), row + 1, col + 1, tokenValue));
                    col = next;
                    continue;
                }
                TokenInvalid tokenInvalid = new TokenInvalid(lexFabric, row + 1, col + 1, tokenValue, "Bad identifier.");
                tokenList.add(tokenInvalid);
                tokenInvalid.throwCompileException();
            }
        }
        PythonCompiler.app.logInfo(null, null, "Lexical analyzer finished OK. [" + tokenList.size() + " lexems]");
    }

    private int searchToken(String line, int start) {
        int next = start;
        while (next < line.length()) {
            if ((line.charAt(next) >= 'A' && line.charAt(next) <= 'Z') ||
                    (line.charAt(next) >= 'a' && line.charAt(next) <= 'z') ||
                    (line.charAt(next) >= '0' && line.charAt(next) <= '9') ||
                    line.charAt(next) == '_') {
                next++;
            } else {
                return next;
            }
        }
        return next;
    }

    private boolean checkConstInt(String value, int row, int col) throws CompileException {
        try {
            if (value.startsWith("0x")) {
                if (value.length() == 2) throw new Exception("Bad number format.");
                for (int i = 2; i < value.length(); i++) {
                    if (!((value.charAt(i) >= '0' && value.charAt(i) <= '9') ||
                            (value.charAt(i) >= 'a' && value.charAt(i) <= 'f') ||
                            (value.charAt(i) >= 'A' && value.charAt(i) <= 'F'))) throw new Exception("Bad number format.");
                }
                if(value.length()>10) throw new Exception("Value exceeds the maximum allowable.");
                if (Long.parseLong(value.substring(2), 16) > Integer.MAX_VALUE) throw new Exception("Value exceeds the maximum allowable.");
                return true;
            } else if (value.charAt(0) >= '0' && value.charAt(0) <= '9') {
                for (int i = 0; i < value.length(); i++) {
                    if (value.charAt(i) < '0' || value.charAt(i) > '9') throw new Exception("Bad number format.");
                }
                if(value.length()>10) throw new Exception("Value exceeds the maximum allowable.");
                if (Long.parseLong(value, 10) > Integer.MAX_VALUE) throw new Exception("Value exceeds the maximum allowable.");
                return true;
            } else {
                return false;
            }
        } catch (Exception e){
            TokenInvalid tokenInvalid = new TokenInvalid(lexFabric, row, col, value, e.getMessage());
            tokenList.add(tokenInvalid);
            tokenInvalid.throwCompileException();
            return false;
        }
    }

    private boolean checkId(String value) {
        if (!((value.charAt(0) >= 'A' && value.charAt(0) <= 'Z') || (value.charAt(0) >= 'a' && value.charAt(0) <= 'z')))
            return false;
        for (int i = 1; i < value.length(); i++) {
            if (!((value.charAt(i) >= 'A' && value.charAt(i) <= 'Z') ||
                    (value.charAt(i) >= 'a' && value.charAt(i) <= 'z') ||
                    (value.charAt(i) >= '0' && value.charAt(i) <= '9') ||
                    value.charAt(i) == '_'))
                return false;
        }
        return true;
    }

    public void printTokenList(){
        System.out.println(PythonCompiler.NAME_PRG+"TOKEN LIST:");
        System.out.println(PythonCompiler.NAME_PRG+"-----------------------------------------------");
        for(Token token: tokenList){
            System.out.println(PythonCompiler.NAME_PRG+"  "+token.toString());
        }
        System.out.println(PythonCompiler.NAME_PRG+"-----------------------------------------------");
    }
}
LexType.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public abstract class LexType {
    private LexicalAnalyzer lexicalAnalyzer;
    public abstract LexTypeEnum getType();
}
LexTypeEnum.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public enum LexTypeEnum {
    NONE, BLOCKINDENT, SYMB, BKTB, BKTE, COLON, QUOTE1, QUOTE2, KEYWORD, DEF, RETURN, CONST, CONSTINT, CONSTCHAR, ID;
}
LexType_bktb.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_bktb extends LexType_symb {
    public LexTypeEnum getType(){
        return LexTypeEnum.BKTB;
    }
}
LexType_bkte.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_bkte extends LexType_symb {
    public LexTypeEnum getType(){
        return LexTypeEnum.BKTE;
    }
}
LexType_blockindent.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_blockindent extends LexType {
    public LexTypeEnum getType(){
        return LexTypeEnum.BLOCKINDENT;
    }
}
LexType_colon.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_colon extends LexType_symb {
    public LexTypeEnum getType(){
        return LexTypeEnum.COLON;
    }
}
LexType_const.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public abstract class LexType_const extends LexType {
}
LexType_constchar.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_constchar extends LexType_const {
    public LexTypeEnum getType(){
        return LexTypeEnum.CONSTCHAR;
    }
}
LexType_constint.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_constint extends LexType_const {
    public LexTypeEnum getType(){
        return LexTypeEnum.CONSTINT;
    }
}
LexType_def.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_def extends LexType_keyword {
    public LexTypeEnum getType(){
        return LexTypeEnum.DEF;
    }
}
LexType_id.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_id extends LexType {
    public LexTypeEnum getType(){
        return LexTypeEnum.ID;
    }
}
LexType_keyword.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public abstract class LexType_keyword extends LexType {
}
LexType_none.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_none extends LexType {
    public LexTypeEnum getType(){
        return LexTypeEnum.NONE;
    }
}
LexType_quote1.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_quote1 extends LexType_symb {
    public LexTypeEnum getType(){
        return LexTypeEnum.QUOTE1;
    }
}
LexType_quote2.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_quote2 extends LexType_symb {
    public LexTypeEnum getType(){
        return LexTypeEnum.QUOTE2;
    }
}
LexType_return.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public class LexType_return extends LexType_keyword {
    public LexTypeEnum getType(){
        return LexTypeEnum.RETURN;
    }
}
LexType_symb.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

public abstract class LexType_symb extends LexType {
}
Token.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class Token {
    private LexType lexType;
    private int row;
    private int col;
    private String value;

    @Override
    public String toString(){
        return "["+row+","+col+"]["+lexType.getType()+"]"+(value==null?"":" -> ["+value+"]");
    }

    public void generateCompileException(String errMsg) throws CompileException {
        new TokenInvalid(this, errMsg).throwCompileException();
    }
}
TokenInvalid.java
======================================================================
package edu.kpi.io8322.sysprog.lab.lexical;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import lombok.Getter;

@Getter
public class TokenInvalid extends Token {
    private Token real;
    private String errMsg;

    public TokenInvalid(Token real, String errMsg) {
        super(real.getLexType(), real.getRow(), real.getCol(), real.getValue());
        this.real = real;
        this.errMsg = errMsg;
    }

    public TokenInvalid(LexFabric lexFabric, int row, int col, String value, String errMsg) {
        super(lexFabric.getLexType(LexTypeEnum.NONE), row, col, value);
        this.errMsg = errMsg;
    }

    public void throwCompileException() throws CompileException {
        throw new CompileException(this);
    }

    @Override
    public String toString(){
        return "["+getRow()+","+getCol()+"]["+getLexType().getType()+".INVALID]"+(getValue()==null?"":" -> ["+getValue()+"]")+(errMsg==null?"":" // "+errMsg);
    }
}
PythonCompiler.java
======================================================================
package edu.kpi.io8322.sysprog.lab;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import edu.kpi.io8322.sysprog.lab.lexical.LexicalAnalyzer;
import edu.kpi.io8322.sysprog.lab.syntax.SyntaxAnalyzer;
import lombok.Getter;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

@Getter
public class PythonCompiler {
    public static final String NAME_PRG = "[2-20-Java-IO-83-Omelyanskyi] ";
    private static final String LOG_FORMAT = NAME_PRG+"[%1$-10s] [%2$-7s] %3$s";
    public static PythonCompiler app;

    private String srcname;
    private String dstname;
    private List<String> srclines;
    private LexicalAnalyzer lexicalAnalyzer;
    private SyntaxAnalyzer syntaxAnalyzer;

    public PythonCompiler(String srcname) {
        this.srcname = srcname;
        if (srcname.endsWith(".py")) {
            dstname = srcname.substring(0, srcname.length() - ".py".length()) + ".asm";
        } else {
            dstname = srcname + ".asm";
        }
    }

    public int exec() {
        logInfo(null, null, "Source file: " + srcname);
        srclines = new ArrayList<>();
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(srcname));
            String line = br.readLine();
            while (line != null) {
                srclines.add(line);
                line = br.readLine();
            }
            br.close();
            logInfo(null, null, "Read " + srclines.size() + " rows.");
        } catch (Throwable e) {
            logError(null, null, "Error read file " + srcname);
            if (br != null) {
                try {
                    br.close();
                } catch (Throwable e1) {
                }
            }
            return 1;
        }
        lexicalAnalyzer = new LexicalAnalyzer(srclines);
        try {
            lexicalAnalyzer.exec();
            lexicalAnalyzer.printTokenList();;
        } catch(CompileException e){
            lexicalAnalyzer.printTokenList();;
            logError("Lexical", null, e.toString());
            return 1;
        }
        syntaxAnalyzer = new SyntaxAnalyzer(lexicalAnalyzer.getTokenList());
        try {
            syntaxAnalyzer.exec();
            syntaxAnalyzer.printTree();
        } catch(CompileException e){
            syntaxAnalyzer.printTree();
            logError("Syntax", null, e.toString());
            return 1;
        }
        try {
            logInfo(null, null, "Generate destination files");
            StringWriter stringWriter = new StringWriter();
            BufferedWriter writer = new BufferedWriter(stringWriter);
            syntaxAnalyzer.execOut(writer);
            writer.close();
            String bodyResultFile = new String(stringWriter.getBuffer());
            BufferedWriter writerFile = new BufferedWriter(new FileWriter(dstname));
            writerFile.write(bodyResultFile);
            writerFile.close();
        } catch (Throwable e){
            logError("Generator", null, e.toString());
            return 1;
        }
        logInfo(null, null, "Result file: " + dstname);
        return 0;
    }

    public void logInfo(String sourceClass, String sourceMethod, String msg) {
        if (sourceClass == null) {
            System.out.println(String.format(LOG_FORMAT, "Compiler", "INFO", msg));
        } else {
            System.out.println(String.format(LOG_FORMAT, sourceClass, "INFO", msg));
        }
    }

    public void logError(String sourceClass, String sourceMethod, String msg) {
        if (sourceClass == null) {
            System.out.println(String.format(LOG_FORMAT, "Compiler", "ERROR", msg));
        } else {
            System.out.println(String.format(LOG_FORMAT, sourceClass, "ERROR", msg));
        }
    }

    public static void main(String[] argc) {
        if (argc.length < 1) {
            System.out.println("Usage: PythonCompiler <source_file>");
            System.out.println();
            System.exit(1);
        }
        PythonCompiler.app = new PythonCompiler(argc[0]);
        long timeexec = System.currentTimeMillis();
        PythonCompiler.app.logInfo(null, null, "Python compiler");
        int exitcode = PythonCompiler.app.exec();
        switch (exitcode) {
            case 0:
                PythonCompiler.app.logInfo(null, null, "Python Compiler finished OK. [ " + (System.currentTimeMillis() - timeexec) + " ms]");
                break;
            default:
                PythonCompiler.app.logError(null, null, "Python Compiler finished ERROR. [ " + (System.currentTimeMillis() - timeexec) + " ms]");
                break;
        }
        System.exit(exitcode);
    }
}


Expr.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;

import java.io.IOException;

public abstract class Expr extends Node {
    public Expr(int row, int col){
        super(row, col);
    }

    public String outGetValue(SyntaxAnalyzer prg) throws CompileException, IOException {
        return null;
    }
}
Expr_Const.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

public abstract class Expr_Const extends Expr {
    public Expr_Const(int row, int col){
        super(row, col);
    }
}
Expr_ConstInt.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import edu.kpi.io8322.sysprog.lab.lexical.Token;
import lombok.Getter;

import java.io.IOException;

@Getter
public class Expr_ConstInt extends Expr_Const {
    private int value;

    public Expr_ConstInt(int row, int col, Token token) throws CompileException {
        super(row, col);
        switch (token.getLexType().getType()) {
            case CONSTINT:
                try {
                    if (token.getValue().startsWith("0x")) {
                        value = Integer.parseInt(token.getValue().substring(2), 16);
                    } else {
                        value = Integer.parseInt(token.getValue(), 10);
                    }
                } catch (Throwable e) {
                    token.generateCompileException("Bad format number");
                }
                break;
            case CONSTCHAR:
                value = token.getValue().charAt(0);
                break;
            default:
                token.generateCompileException("Not integer constant.");
        }
    }

    public NodeType getType(){
        return NodeType.EXPR_CONSTINT;
    }

    public void printTree(StringBuilder buf, String indent){
        buf.append(indent+"["+getType()+"]: \""+value+"\""+System.lineSeparator());
    }

    public String outGetValue(SyntaxAnalyzer prg) throws CompileException, IOException {
        return ""+value;
    }
}
Expr_Id.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import edu.kpi.io8322.sysprog.lab.lexical.LexTypeEnum;
import edu.kpi.io8322.sysprog.lab.lexical.Token;
import lombok.Getter;

@Getter
public abstract class Expr_Id extends Expr {
    private String name;

    public Expr_Id(Token token) throws CompileException {
        super(token.getRow(), token.getCol());
        if(token.getLexType().getType()!=LexTypeEnum.ID) token.generateCompileException("Token not identifier.");
        this.name = token.getValue();
    }

    public void printTree(StringBuilder buf, String indent){
        buf.append(indent+"["+getType()+"]: \""+name+"\""+System.lineSeparator());
    }
}
Expr_IdFunction.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import edu.kpi.io8322.sysprog.lab.lexical.Token;

public class Expr_IdFunction extends Expr_Id {
    public Expr_IdFunction(Token token) throws CompileException {
        super(token);
    }

    public NodeType getType(){
        return NodeType.EXPR_IDFUNCTION;
    }
}
Expr_IdVar.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import edu.kpi.io8322.sysprog.lab.lexical.Token;

public class Expr_IdVar extends Expr_Id {
    public Expr_IdVar(Token token) throws CompileException {
        super(token);
    }

    public NodeType getType(){
        return NodeType.EXPR_IDVAR;
    }
}
Node.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import lombok.Getter;

@Getter
public abstract class Node {
    private int row;
    private int col;

    public Node(int row, int col) {
        this.row = row;
        this.col = col;
    }

    public abstract NodeType getType();

    public abstract void printTree(StringBuilder buf, String indent);
}
NodeType.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

public enum NodeType {
    NONE, EXPR, EXPR_CONST, EXPR_CONSTINT, EXPR_ID, EXPR_IDFUNCTION, EXPR_IDVAR,
    STMT, STMT_RETURN, STMT_BLOCK, STMT_FUNCTION, STMT_PROGRAM
}
Stmt.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;

import java.io.IOException;

public abstract class Stmt extends Node {
    public Stmt(int row, int col) {
        super(row, col);
    }

    public void gen(SyntaxAnalyzer prg, int labelBegin, int labelAfter) throws CompileException, IOException {
    }
}
Stmt_Block.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import lombok.Getter;
import lombok.Setter;

import java.io.IOException;

@Getter
@Setter
public class Stmt_Block extends Stmt {
    private Stmt body;

    public Stmt_Block(int row, int col) {
        super(row, col);
    }

    public NodeType getType(){
        return NodeType.STMT_BLOCK;
    }

    public void printTree(StringBuilder buf, String indent){
        buf.append(indent+"["+getType()+"]"+System.lineSeparator());
        if(body!=null){
            buf.append(indent+"  {bodyBlock}:"+System.lineSeparator());
            body.printTree(buf, indent+"    ");
        }
    }

    @Override
    public void gen(SyntaxAnalyzer prg, int labelBegin, int labelAfter) throws CompileException, IOException {
        if(body!=null){
            body.gen(prg, 0, 0);
        }
    }

}
Stmt_Function.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import lombok.Getter;
import lombok.Setter;

import java.io.IOException;

@Getter
@Setter
public class Stmt_Function extends Stmt {
    private Expr_IdFunction name;
    private Stmt_Block body;

    public Stmt_Function(int row, int col, Expr_IdFunction name) {
        super(row, col);
        this.name = name;
    }

    public NodeType getType() {
        return NodeType.STMT_FUNCTION;
    }

    public void printTree(StringBuilder buf, String indent) {
        buf.append(indent + "[" + getType() + "]" + System.lineSeparator());
        buf.append(indent + "  {nameFunction}:" + System.lineSeparator());
        name.printTree(buf, indent+"    ");
        if (body != null) {
            buf.append(indent + "  {bodyFunction}:" + System.lineSeparator());
            body.printTree(buf, indent+"    ");
        }
    }

    @Override
    public void gen(SyntaxAnalyzer prg, int labelBegin, int labelAfter) throws CompileException, IOException {
        prg.outWriteln(name.getName()+" PROC");
        if(body!=null){
            body.gen(prg, 0, 0);
        }
        prg.outWriteln(name.getName()+" ENDP");
    }
}
Stmt_Program.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import lombok.Getter;
import lombok.Setter;

import java.io.IOException;

@Getter
@Setter
public class Stmt_Program extends Stmt {
    private Stmt_Function stmtFunction;

    public Stmt_Program() {
        super(1, 1);
    }

    public NodeType getType(){
        return NodeType.STMT_PROGRAM;
    }

    public void printTree(StringBuilder buf, String indent){
        buf.append(indent+"["+getType()+"]"+System.lineSeparator());
        if(stmtFunction!=null){
            buf.append(indent+"  {function}:"+System.lineSeparator());
            stmtFunction.printTree(buf, indent+"    ");
        }
    }

    @Override
    public void gen(SyntaxAnalyzer prg, int labelBegin, int labelAfter) throws CompileException, IOException {
        prg.outWriteln(".586");
        prg.outWriteln(".model flat, stdcall");
        prg.outWriteln("option casemap:none");
        prg.outWriteln("include \\masm32\\include\\windows.inc");
        prg.outWriteln("include \\masm32\\include\\kernel32.inc");
        prg.outWriteln("include \\masm32\\include\\masm32.inc");
        prg.outWriteln("includelib \\masm32\\lib\\kernel32.lib");
        prg.outWriteln("includelib \\masm32\\lib\\masm32.lib");
        prg.outWriteln("NumbToStr PROTO :DWORD,:DWORD");
        prg.outWriteln(stmtFunction.getName().getName()+" PROTO");
        prg.outWriteln(".data");
        prg.outWriteln("\tbuff db 11 dup(?)");
        prg.outWriteln(".code");
        prg.outWriteln("start:");
        prg.outWriteln("\tinvoke main");
        prg.outWriteln("\tinvoke NumbToStr, ebx, ADDR buff");
        prg.outWriteln("\tinvoke StdOut,eax");
        prg.outWriteln("\tinvoke ExitProcess,0");
        stmtFunction.gen(prg, 0, 0);
        prg.outWriteln("NumbToStr PROC uses ebx x:DWORD,buffer:DWORD");
        prg.outWriteln("\tmov eax,x");
        prg.outWriteln("\ttest eax,80000000h");
        prg.outWriteln("\tjz LL2");
        prg.outWriteln("\tpush dword ptr 2Dh");
        prg.outWriteln("\tneg eax");
        prg.outWriteln("\tjmp LL3");
        prg.outWriteln("LL2:");
        prg.outWriteln("\tpush dword ptr 20h");
        prg.outWriteln("LL3:");
        prg.outWriteln("\tmov ecx,buffer");
        prg.outWriteln("\tmov ebx,10");
        prg.outWriteln("\tadd ecx,ebx");
        prg.outWriteln("LL1:");
        prg.outWriteln("\txor edx,edx");
        prg.outWriteln("\tdiv ebx");
        prg.outWriteln("\tadd edx,48");
        prg.outWriteln("\tmov BYTE PTR [ecx],dl");
        prg.outWriteln("\tdec ecx");
        prg.outWriteln("\ttest eax,eax");
        prg.outWriteln("\tjnz LL1");
        prg.outWriteln("\tpop edx");
        prg.outWriteln("\tmov BYTE PTR [ecx],dl");
        prg.outWriteln("\tmov eax,ecx");
        prg.outWriteln("\tret");
        prg.outWriteln("NumbToStr ENDP");
        prg.outWriteln("end start");
    }

}
Stmt_Return.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.core.CompileException;
import lombok.Getter;

import java.io.IOException;

@Getter
public class Stmt_Return extends Stmt {
    private Stmt_Function stmtFunction;
    private Expr retValue;

    public Stmt_Return(int row, int col, Stmt_Function stmtFunction, Expr retValue) {
        super(row, col);
        this.stmtFunction = stmtFunction;
        this.retValue = retValue;
    }

    public NodeType getType(){
        return NodeType.STMT_RETURN;
    }

    public void printTree(StringBuilder buf, String indent){
        buf.append(indent+"["+getType()+"]"+System.lineSeparator());
        buf.append(indent+"  {retValue}:"+System.lineSeparator());
        retValue.printTree(buf, indent+"    ");
    }

    @Override
    public void gen(SyntaxAnalyzer prg, int labelBegin, int labelAfter) throws CompileException, IOException {
        prg.outWriteln("\tmov ebx,"+retValue.outGetValue(prg));
        prg.outWriteln("\tret");
    }

}
SyntaxAnalyzer.java
======================================================================
package edu.kpi.io8322.sysprog.lab.syntax;

import edu.kpi.io8322.sysprog.lab.PythonCompiler;
import edu.kpi.io8322.sysprog.lab.core.CompileException;
import edu.kpi.io8322.sysprog.lab.lexical.LexTypeEnum;
import edu.kpi.io8322.sysprog.lab.lexical.Token;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SyntaxAnalyzer {
    private List<Token> tokenList;
    private Stmt_Program root;
    private int tokenIndexCur;
    private Map<Stmt, String> blockIndentMap;
    private Stmt_Function functionCur;
    private int labelIndexCur;
    private Writer out;

    public SyntaxAnalyzer(List<Token> tokenList) {
        this.tokenList = tokenList;
    }

    public Stmt_Program getRoot(){
        return root;
    }

    public Token tokenCur() throws CompileException {
        if (tokenIndexCur < tokenList.size())
            return tokenList.get(tokenIndexCur);
        throw new CompileException(1, 1, "Attempt to parse past end of file.", null);
    }

    public Token tokenPeek(int step) {
        if (tokenIndexCur + step < tokenList.size())
            return tokenList.get(tokenIndexCur + step);
        return null;
    }

    public void tokenNext() {
        tokenIndexCur++;
    }

    public void exec() throws CompileException {
        PythonCompiler.app.logInfo(null, null, "Syntax analyzer starting.");
        tokenIndexCur = 0;
        blockIndentMap = new HashMap<>();
        functionCur = null;
        root = new Stmt_Program();
        if (tokenCur().getLexType().getType() != LexTypeEnum.BLOCKINDENT)
            tokenCur().generateCompileException("Token not block indent.");
        blockIndentMap.put(root, tokenCur().getValue());
        tokenNext();
        root.setStmtFunction(parseFunction());
        PythonCompiler.app.logInfo(null, null, "Syntax analyzer finished OK.");
    }

    public Stmt_Function parseFunction() throws CompileException {
        Token tokenDef = tokenCur();
        if (tokenDef.getLexType().getType() != LexTypeEnum.DEF)
            tokenDef.generateCompileException("Token not keyword \"def\".");
        tokenNext();
        Expr_IdFunction nameFunction = new Expr_IdFunction(tokenCur());
        Stmt_Function stmtFunction = new Stmt_Function(tokenDef.getRow(), tokenDef.getCol(), nameFunction);
        functionCur = stmtFunction;
        tokenNext();
        if(tokenCur().getLexType().getType()!=LexTypeEnum.BKTB) tokenCur().generateCompileException("Not symbol \"(\".");
        tokenNext();
        if(tokenCur().getLexType().getType()!=LexTypeEnum.BKTE) tokenCur().generateCompileException("Not symbol \")\".");
        tokenNext();
        if(tokenCur().getLexType().getType()!=LexTypeEnum.COLON) tokenCur().generateCompileException("Not symbol \":\".");
        tokenNext();
        stmtFunction.setBody(parseBlock());
        functionCur = null;
        return stmtFunction;
    }

    public Stmt_Block parseBlock() throws CompileException {
        if (tokenCur().getLexType().getType() != LexTypeEnum.BLOCKINDENT)
            tokenCur().generateCompileException("Token not block indent.");
        Stmt_Block stmt_block = new Stmt_Block(tokenCur().getRow(), tokenCur().getCol());
        blockIndentMap.put(stmt_block, tokenCur().getValue());
        tokenNext();
        stmt_block.setBody(parseReturn());
        blockIndentMap.remove(stmt_block);
        return stmt_block;
    }

    public Stmt_Return parseReturn() throws CompileException {
        Token tokenReturn = tokenCur();
        if (tokenReturn.getLexType().getType() != LexTypeEnum.RETURN)
            tokenReturn.generateCompileException("Token not keyword \"return\".");
        if(functionCur==null) tokenReturn.generateCompileException("Return without function.");
        tokenNext();
        return new Stmt_Return(tokenReturn.getRow(),tokenReturn.getCol(), functionCur, parseExpr());
    }

    public Expr parseExpr() throws CompileException {
        Token quoteBegin = null;
        if(tokenCur().getLexType().getType()==LexTypeEnum.QUOTE1 || tokenCur().getLexType().getType()==LexTypeEnum.QUOTE2){
            quoteBegin = tokenCur();
            tokenNext();
        }
        Expr_ConstInt expr = new Expr_ConstInt(tokenCur().getRow(), tokenCur().getCol(), tokenCur());
        tokenNext();
        if(quoteBegin!=null){
            if(tokenCur().getLexType().getType()!=quoteBegin.getLexType().getType()) tokenCur().generateCompileException("Not close quote.");
            tokenNext();
        }
        return expr;
    }

    public void printTree() {
        System.out.println(PythonCompiler.NAME_PRG+"SYNTAX TREE:");
        System.out.println(PythonCompiler.NAME_PRG+"-----------------------------------------------");
        StringBuilder bufPrint = new StringBuilder();
        root.printTree(bufPrint, PythonCompiler.NAME_PRG+"");
        System.out.println(bufPrint);
        System.out.println(PythonCompiler.NAME_PRG+"-----------------------------------------------");
    }

    public int newLabel() {
        labelIndexCur++;
        return labelIndexCur;
    }

    public String strLabel(int num) {
        if(num>0) return "L"+num;
        return null;
    }

    public void outWriteLabel(int num) throws IOException {
        if (num > 0)
            out.write("L" + num + ":" + System.lineSeparator());
    }

    public void outWriteln(String str) throws IOException {
        if (str != null && !str.isEmpty()) out.write(str);
        out.write(System.lineSeparator());
    }

    public void execOut(Writer out) throws CompileException, IOException {
        this.out = out;
        labelIndexCur = 0;
        root.gen(this, 0, 0);
    }

}
